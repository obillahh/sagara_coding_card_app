// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'avatar_update_response_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

AvatarUpdateResponseModel _$AvatarUpdateResponseModelFromJson(
    Map<String, dynamic> json) {
  return _AvatarUpdateResponseModel.fromJson(json);
}

/// @nodoc
mixin _$AvatarUpdateResponseModel {
  @JsonKey(name: "id")
  int? get id => throw _privateConstructorUsedError;
  @JsonKey(name: "name")
  String? get name => throw _privateConstructorUsedError;
  @JsonKey(name: "alternativeText")
  dynamic get alternativeText => throw _privateConstructorUsedError;
  @JsonKey(name: "caption")
  dynamic get caption => throw _privateConstructorUsedError;
  @JsonKey(name: "width")
  int? get width => throw _privateConstructorUsedError;
  @JsonKey(name: "height")
  int? get height => throw _privateConstructorUsedError;
  @JsonKey(name: "formats")
  FormatsAvatarUpdateResponseModel? get formats =>
      throw _privateConstructorUsedError;
  @JsonKey(name: "hash")
  String? get hash => throw _privateConstructorUsedError;
  @JsonKey(name: "ext")
  String? get ext => throw _privateConstructorUsedError;
  @JsonKey(name: "mime")
  String? get mime => throw _privateConstructorUsedError;
  @JsonKey(name: "size")
  double? get size => throw _privateConstructorUsedError;
  @JsonKey(name: "url")
  String? get url => throw _privateConstructorUsedError;
  @JsonKey(name: "previewUrl")
  dynamic get previewUrl => throw _privateConstructorUsedError;
  @JsonKey(name: "provider")
  String? get provider => throw _privateConstructorUsedError;
  @JsonKey(name: "provider_metadata")
  dynamic get providerMetadata => throw _privateConstructorUsedError;
  @JsonKey(name: "createdAt")
  DateTime? get createdAt => throw _privateConstructorUsedError;
  @JsonKey(name: "updatedAt")
  DateTime? get updatedAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AvatarUpdateResponseModelCopyWith<AvatarUpdateResponseModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AvatarUpdateResponseModelCopyWith<$Res> {
  factory $AvatarUpdateResponseModelCopyWith(AvatarUpdateResponseModel value,
          $Res Function(AvatarUpdateResponseModel) then) =
      _$AvatarUpdateResponseModelCopyWithImpl<$Res, AvatarUpdateResponseModel>;
  @useResult
  $Res call(
      {@JsonKey(name: "id") int? id,
      @JsonKey(name: "name") String? name,
      @JsonKey(name: "alternativeText") dynamic alternativeText,
      @JsonKey(name: "caption") dynamic caption,
      @JsonKey(name: "width") int? width,
      @JsonKey(name: "height") int? height,
      @JsonKey(name: "formats") FormatsAvatarUpdateResponseModel? formats,
      @JsonKey(name: "hash") String? hash,
      @JsonKey(name: "ext") String? ext,
      @JsonKey(name: "mime") String? mime,
      @JsonKey(name: "size") double? size,
      @JsonKey(name: "url") String? url,
      @JsonKey(name: "previewUrl") dynamic previewUrl,
      @JsonKey(name: "provider") String? provider,
      @JsonKey(name: "provider_metadata") dynamic providerMetadata,
      @JsonKey(name: "createdAt") DateTime? createdAt,
      @JsonKey(name: "updatedAt") DateTime? updatedAt});

  $FormatsAvatarUpdateResponseModelCopyWith<$Res>? get formats;
}

/// @nodoc
class _$AvatarUpdateResponseModelCopyWithImpl<$Res,
        $Val extends AvatarUpdateResponseModel>
    implements $AvatarUpdateResponseModelCopyWith<$Res> {
  _$AvatarUpdateResponseModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? alternativeText = freezed,
    Object? caption = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? formats = freezed,
    Object? hash = freezed,
    Object? ext = freezed,
    Object? mime = freezed,
    Object? size = freezed,
    Object? url = freezed,
    Object? previewUrl = freezed,
    Object? provider = freezed,
    Object? providerMetadata = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      alternativeText: freezed == alternativeText
          ? _value.alternativeText
          : alternativeText // ignore: cast_nullable_to_non_nullable
              as dynamic,
      caption: freezed == caption
          ? _value.caption
          : caption // ignore: cast_nullable_to_non_nullable
              as dynamic,
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      formats: freezed == formats
          ? _value.formats
          : formats // ignore: cast_nullable_to_non_nullable
              as FormatsAvatarUpdateResponseModel?,
      hash: freezed == hash
          ? _value.hash
          : hash // ignore: cast_nullable_to_non_nullable
              as String?,
      ext: freezed == ext
          ? _value.ext
          : ext // ignore: cast_nullable_to_non_nullable
              as String?,
      mime: freezed == mime
          ? _value.mime
          : mime // ignore: cast_nullable_to_non_nullable
              as String?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      previewUrl: freezed == previewUrl
          ? _value.previewUrl
          : previewUrl // ignore: cast_nullable_to_non_nullable
              as dynamic,
      provider: freezed == provider
          ? _value.provider
          : provider // ignore: cast_nullable_to_non_nullable
              as String?,
      providerMetadata: freezed == providerMetadata
          ? _value.providerMetadata
          : providerMetadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FormatsAvatarUpdateResponseModelCopyWith<$Res>? get formats {
    if (_value.formats == null) {
      return null;
    }

    return $FormatsAvatarUpdateResponseModelCopyWith<$Res>(_value.formats!,
        (value) {
      return _then(_value.copyWith(formats: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AvatarUpdateResponseModelImplCopyWith<$Res>
    implements $AvatarUpdateResponseModelCopyWith<$Res> {
  factory _$$AvatarUpdateResponseModelImplCopyWith(
          _$AvatarUpdateResponseModelImpl value,
          $Res Function(_$AvatarUpdateResponseModelImpl) then) =
      __$$AvatarUpdateResponseModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "id") int? id,
      @JsonKey(name: "name") String? name,
      @JsonKey(name: "alternativeText") dynamic alternativeText,
      @JsonKey(name: "caption") dynamic caption,
      @JsonKey(name: "width") int? width,
      @JsonKey(name: "height") int? height,
      @JsonKey(name: "formats") FormatsAvatarUpdateResponseModel? formats,
      @JsonKey(name: "hash") String? hash,
      @JsonKey(name: "ext") String? ext,
      @JsonKey(name: "mime") String? mime,
      @JsonKey(name: "size") double? size,
      @JsonKey(name: "url") String? url,
      @JsonKey(name: "previewUrl") dynamic previewUrl,
      @JsonKey(name: "provider") String? provider,
      @JsonKey(name: "provider_metadata") dynamic providerMetadata,
      @JsonKey(name: "createdAt") DateTime? createdAt,
      @JsonKey(name: "updatedAt") DateTime? updatedAt});

  @override
  $FormatsAvatarUpdateResponseModelCopyWith<$Res>? get formats;
}

/// @nodoc
class __$$AvatarUpdateResponseModelImplCopyWithImpl<$Res>
    extends _$AvatarUpdateResponseModelCopyWithImpl<$Res,
        _$AvatarUpdateResponseModelImpl>
    implements _$$AvatarUpdateResponseModelImplCopyWith<$Res> {
  __$$AvatarUpdateResponseModelImplCopyWithImpl(
      _$AvatarUpdateResponseModelImpl _value,
      $Res Function(_$AvatarUpdateResponseModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? alternativeText = freezed,
    Object? caption = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? formats = freezed,
    Object? hash = freezed,
    Object? ext = freezed,
    Object? mime = freezed,
    Object? size = freezed,
    Object? url = freezed,
    Object? previewUrl = freezed,
    Object? provider = freezed,
    Object? providerMetadata = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
  }) {
    return _then(_$AvatarUpdateResponseModelImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      alternativeText: freezed == alternativeText
          ? _value.alternativeText
          : alternativeText // ignore: cast_nullable_to_non_nullable
              as dynamic,
      caption: freezed == caption
          ? _value.caption
          : caption // ignore: cast_nullable_to_non_nullable
              as dynamic,
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      formats: freezed == formats
          ? _value.formats
          : formats // ignore: cast_nullable_to_non_nullable
              as FormatsAvatarUpdateResponseModel?,
      hash: freezed == hash
          ? _value.hash
          : hash // ignore: cast_nullable_to_non_nullable
              as String?,
      ext: freezed == ext
          ? _value.ext
          : ext // ignore: cast_nullable_to_non_nullable
              as String?,
      mime: freezed == mime
          ? _value.mime
          : mime // ignore: cast_nullable_to_non_nullable
              as String?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      previewUrl: freezed == previewUrl
          ? _value.previewUrl
          : previewUrl // ignore: cast_nullable_to_non_nullable
              as dynamic,
      provider: freezed == provider
          ? _value.provider
          : provider // ignore: cast_nullable_to_non_nullable
              as String?,
      providerMetadata: freezed == providerMetadata
          ? _value.providerMetadata
          : providerMetadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AvatarUpdateResponseModelImpl implements _AvatarUpdateResponseModel {
  const _$AvatarUpdateResponseModelImpl(
      {@JsonKey(name: "id") this.id,
      @JsonKey(name: "name") this.name,
      @JsonKey(name: "alternativeText") this.alternativeText,
      @JsonKey(name: "caption") this.caption,
      @JsonKey(name: "width") this.width,
      @JsonKey(name: "height") this.height,
      @JsonKey(name: "formats") this.formats,
      @JsonKey(name: "hash") this.hash,
      @JsonKey(name: "ext") this.ext,
      @JsonKey(name: "mime") this.mime,
      @JsonKey(name: "size") this.size,
      @JsonKey(name: "url") this.url,
      @JsonKey(name: "previewUrl") this.previewUrl,
      @JsonKey(name: "provider") this.provider,
      @JsonKey(name: "provider_metadata") this.providerMetadata,
      @JsonKey(name: "createdAt") this.createdAt,
      @JsonKey(name: "updatedAt") this.updatedAt});

  factory _$AvatarUpdateResponseModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$AvatarUpdateResponseModelImplFromJson(json);

  @override
  @JsonKey(name: "id")
  final int? id;
  @override
  @JsonKey(name: "name")
  final String? name;
  @override
  @JsonKey(name: "alternativeText")
  final dynamic alternativeText;
  @override
  @JsonKey(name: "caption")
  final dynamic caption;
  @override
  @JsonKey(name: "width")
  final int? width;
  @override
  @JsonKey(name: "height")
  final int? height;
  @override
  @JsonKey(name: "formats")
  final FormatsAvatarUpdateResponseModel? formats;
  @override
  @JsonKey(name: "hash")
  final String? hash;
  @override
  @JsonKey(name: "ext")
  final String? ext;
  @override
  @JsonKey(name: "mime")
  final String? mime;
  @override
  @JsonKey(name: "size")
  final double? size;
  @override
  @JsonKey(name: "url")
  final String? url;
  @override
  @JsonKey(name: "previewUrl")
  final dynamic previewUrl;
  @override
  @JsonKey(name: "provider")
  final String? provider;
  @override
  @JsonKey(name: "provider_metadata")
  final dynamic providerMetadata;
  @override
  @JsonKey(name: "createdAt")
  final DateTime? createdAt;
  @override
  @JsonKey(name: "updatedAt")
  final DateTime? updatedAt;

  @override
  String toString() {
    return 'AvatarUpdateResponseModel(id: $id, name: $name, alternativeText: $alternativeText, caption: $caption, width: $width, height: $height, formats: $formats, hash: $hash, ext: $ext, mime: $mime, size: $size, url: $url, previewUrl: $previewUrl, provider: $provider, providerMetadata: $providerMetadata, createdAt: $createdAt, updatedAt: $updatedAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AvatarUpdateResponseModelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality()
                .equals(other.alternativeText, alternativeText) &&
            const DeepCollectionEquality().equals(other.caption, caption) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.formats, formats) || other.formats == formats) &&
            (identical(other.hash, hash) || other.hash == hash) &&
            (identical(other.ext, ext) || other.ext == ext) &&
            (identical(other.mime, mime) || other.mime == mime) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.url, url) || other.url == url) &&
            const DeepCollectionEquality()
                .equals(other.previewUrl, previewUrl) &&
            (identical(other.provider, provider) ||
                other.provider == provider) &&
            const DeepCollectionEquality()
                .equals(other.providerMetadata, providerMetadata) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      const DeepCollectionEquality().hash(alternativeText),
      const DeepCollectionEquality().hash(caption),
      width,
      height,
      formats,
      hash,
      ext,
      mime,
      size,
      url,
      const DeepCollectionEquality().hash(previewUrl),
      provider,
      const DeepCollectionEquality().hash(providerMetadata),
      createdAt,
      updatedAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AvatarUpdateResponseModelImplCopyWith<_$AvatarUpdateResponseModelImpl>
      get copyWith => __$$AvatarUpdateResponseModelImplCopyWithImpl<
          _$AvatarUpdateResponseModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AvatarUpdateResponseModelImplToJson(
      this,
    );
  }
}

abstract class _AvatarUpdateResponseModel implements AvatarUpdateResponseModel {
  const factory _AvatarUpdateResponseModel(
      {@JsonKey(name: "id") final int? id,
      @JsonKey(name: "name") final String? name,
      @JsonKey(name: "alternativeText") final dynamic alternativeText,
      @JsonKey(name: "caption") final dynamic caption,
      @JsonKey(name: "width") final int? width,
      @JsonKey(name: "height") final int? height,
      @JsonKey(name: "formats") final FormatsAvatarUpdateResponseModel? formats,
      @JsonKey(name: "hash") final String? hash,
      @JsonKey(name: "ext") final String? ext,
      @JsonKey(name: "mime") final String? mime,
      @JsonKey(name: "size") final double? size,
      @JsonKey(name: "url") final String? url,
      @JsonKey(name: "previewUrl") final dynamic previewUrl,
      @JsonKey(name: "provider") final String? provider,
      @JsonKey(name: "provider_metadata") final dynamic providerMetadata,
      @JsonKey(name: "createdAt") final DateTime? createdAt,
      @JsonKey(name: "updatedAt")
      final DateTime? updatedAt}) = _$AvatarUpdateResponseModelImpl;

  factory _AvatarUpdateResponseModel.fromJson(Map<String, dynamic> json) =
      _$AvatarUpdateResponseModelImpl.fromJson;

  @override
  @JsonKey(name: "id")
  int? get id;
  @override
  @JsonKey(name: "name")
  String? get name;
  @override
  @JsonKey(name: "alternativeText")
  dynamic get alternativeText;
  @override
  @JsonKey(name: "caption")
  dynamic get caption;
  @override
  @JsonKey(name: "width")
  int? get width;
  @override
  @JsonKey(name: "height")
  int? get height;
  @override
  @JsonKey(name: "formats")
  FormatsAvatarUpdateResponseModel? get formats;
  @override
  @JsonKey(name: "hash")
  String? get hash;
  @override
  @JsonKey(name: "ext")
  String? get ext;
  @override
  @JsonKey(name: "mime")
  String? get mime;
  @override
  @JsonKey(name: "size")
  double? get size;
  @override
  @JsonKey(name: "url")
  String? get url;
  @override
  @JsonKey(name: "previewUrl")
  dynamic get previewUrl;
  @override
  @JsonKey(name: "provider")
  String? get provider;
  @override
  @JsonKey(name: "provider_metadata")
  dynamic get providerMetadata;
  @override
  @JsonKey(name: "createdAt")
  DateTime? get createdAt;
  @override
  @JsonKey(name: "updatedAt")
  DateTime? get updatedAt;
  @override
  @JsonKey(ignore: true)
  _$$AvatarUpdateResponseModelImplCopyWith<_$AvatarUpdateResponseModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FormatsAvatarUpdateResponseModel _$FormatsAvatarUpdateResponseModelFromJson(
    Map<String, dynamic> json) {
  return _FormatsAvatarUpdateResponseModel.fromJson(json);
}

/// @nodoc
mixin _$FormatsAvatarUpdateResponseModel {
  @JsonKey(name: "small")
  SizeFormatAvatarUpdateResponseModel? get small =>
      throw _privateConstructorUsedError;
  @JsonKey(name: "medium")
  SizeFormatAvatarUpdateResponseModel? get medium =>
      throw _privateConstructorUsedError;
  @JsonKey(name: "thumbnail")
  SizeFormatAvatarUpdateResponseModel? get thumbnail =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FormatsAvatarUpdateResponseModelCopyWith<FormatsAvatarUpdateResponseModel>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FormatsAvatarUpdateResponseModelCopyWith<$Res> {
  factory $FormatsAvatarUpdateResponseModelCopyWith(
          FormatsAvatarUpdateResponseModel value,
          $Res Function(FormatsAvatarUpdateResponseModel) then) =
      _$FormatsAvatarUpdateResponseModelCopyWithImpl<$Res,
          FormatsAvatarUpdateResponseModel>;
  @useResult
  $Res call(
      {@JsonKey(name: "small") SizeFormatAvatarUpdateResponseModel? small,
      @JsonKey(name: "medium") SizeFormatAvatarUpdateResponseModel? medium,
      @JsonKey(name: "thumbnail")
      SizeFormatAvatarUpdateResponseModel? thumbnail});

  $SizeFormatAvatarUpdateResponseModelCopyWith<$Res>? get small;
  $SizeFormatAvatarUpdateResponseModelCopyWith<$Res>? get medium;
  $SizeFormatAvatarUpdateResponseModelCopyWith<$Res>? get thumbnail;
}

/// @nodoc
class _$FormatsAvatarUpdateResponseModelCopyWithImpl<$Res,
        $Val extends FormatsAvatarUpdateResponseModel>
    implements $FormatsAvatarUpdateResponseModelCopyWith<$Res> {
  _$FormatsAvatarUpdateResponseModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? small = freezed,
    Object? medium = freezed,
    Object? thumbnail = freezed,
  }) {
    return _then(_value.copyWith(
      small: freezed == small
          ? _value.small
          : small // ignore: cast_nullable_to_non_nullable
              as SizeFormatAvatarUpdateResponseModel?,
      medium: freezed == medium
          ? _value.medium
          : medium // ignore: cast_nullable_to_non_nullable
              as SizeFormatAvatarUpdateResponseModel?,
      thumbnail: freezed == thumbnail
          ? _value.thumbnail
          : thumbnail // ignore: cast_nullable_to_non_nullable
              as SizeFormatAvatarUpdateResponseModel?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $SizeFormatAvatarUpdateResponseModelCopyWith<$Res>? get small {
    if (_value.small == null) {
      return null;
    }

    return $SizeFormatAvatarUpdateResponseModelCopyWith<$Res>(_value.small!,
        (value) {
      return _then(_value.copyWith(small: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SizeFormatAvatarUpdateResponseModelCopyWith<$Res>? get medium {
    if (_value.medium == null) {
      return null;
    }

    return $SizeFormatAvatarUpdateResponseModelCopyWith<$Res>(_value.medium!,
        (value) {
      return _then(_value.copyWith(medium: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SizeFormatAvatarUpdateResponseModelCopyWith<$Res>? get thumbnail {
    if (_value.thumbnail == null) {
      return null;
    }

    return $SizeFormatAvatarUpdateResponseModelCopyWith<$Res>(_value.thumbnail!,
        (value) {
      return _then(_value.copyWith(thumbnail: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FormatsAvatarUpdateResponseModelImplCopyWith<$Res>
    implements $FormatsAvatarUpdateResponseModelCopyWith<$Res> {
  factory _$$FormatsAvatarUpdateResponseModelImplCopyWith(
          _$FormatsAvatarUpdateResponseModelImpl value,
          $Res Function(_$FormatsAvatarUpdateResponseModelImpl) then) =
      __$$FormatsAvatarUpdateResponseModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "small") SizeFormatAvatarUpdateResponseModel? small,
      @JsonKey(name: "medium") SizeFormatAvatarUpdateResponseModel? medium,
      @JsonKey(name: "thumbnail")
      SizeFormatAvatarUpdateResponseModel? thumbnail});

  @override
  $SizeFormatAvatarUpdateResponseModelCopyWith<$Res>? get small;
  @override
  $SizeFormatAvatarUpdateResponseModelCopyWith<$Res>? get medium;
  @override
  $SizeFormatAvatarUpdateResponseModelCopyWith<$Res>? get thumbnail;
}

/// @nodoc
class __$$FormatsAvatarUpdateResponseModelImplCopyWithImpl<$Res>
    extends _$FormatsAvatarUpdateResponseModelCopyWithImpl<$Res,
        _$FormatsAvatarUpdateResponseModelImpl>
    implements _$$FormatsAvatarUpdateResponseModelImplCopyWith<$Res> {
  __$$FormatsAvatarUpdateResponseModelImplCopyWithImpl(
      _$FormatsAvatarUpdateResponseModelImpl _value,
      $Res Function(_$FormatsAvatarUpdateResponseModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? small = freezed,
    Object? medium = freezed,
    Object? thumbnail = freezed,
  }) {
    return _then(_$FormatsAvatarUpdateResponseModelImpl(
      small: freezed == small
          ? _value.small
          : small // ignore: cast_nullable_to_non_nullable
              as SizeFormatAvatarUpdateResponseModel?,
      medium: freezed == medium
          ? _value.medium
          : medium // ignore: cast_nullable_to_non_nullable
              as SizeFormatAvatarUpdateResponseModel?,
      thumbnail: freezed == thumbnail
          ? _value.thumbnail
          : thumbnail // ignore: cast_nullable_to_non_nullable
              as SizeFormatAvatarUpdateResponseModel?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FormatsAvatarUpdateResponseModelImpl
    implements _FormatsAvatarUpdateResponseModel {
  const _$FormatsAvatarUpdateResponseModelImpl(
      {@JsonKey(name: "small") this.small,
      @JsonKey(name: "medium") this.medium,
      @JsonKey(name: "thumbnail") this.thumbnail});

  factory _$FormatsAvatarUpdateResponseModelImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$FormatsAvatarUpdateResponseModelImplFromJson(json);

  @override
  @JsonKey(name: "small")
  final SizeFormatAvatarUpdateResponseModel? small;
  @override
  @JsonKey(name: "medium")
  final SizeFormatAvatarUpdateResponseModel? medium;
  @override
  @JsonKey(name: "thumbnail")
  final SizeFormatAvatarUpdateResponseModel? thumbnail;

  @override
  String toString() {
    return 'FormatsAvatarUpdateResponseModel(small: $small, medium: $medium, thumbnail: $thumbnail)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FormatsAvatarUpdateResponseModelImpl &&
            (identical(other.small, small) || other.small == small) &&
            (identical(other.medium, medium) || other.medium == medium) &&
            (identical(other.thumbnail, thumbnail) ||
                other.thumbnail == thumbnail));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, small, medium, thumbnail);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FormatsAvatarUpdateResponseModelImplCopyWith<
          _$FormatsAvatarUpdateResponseModelImpl>
      get copyWith => __$$FormatsAvatarUpdateResponseModelImplCopyWithImpl<
          _$FormatsAvatarUpdateResponseModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FormatsAvatarUpdateResponseModelImplToJson(
      this,
    );
  }
}

abstract class _FormatsAvatarUpdateResponseModel
    implements FormatsAvatarUpdateResponseModel {
  const factory _FormatsAvatarUpdateResponseModel(
      {@JsonKey(name: "small") final SizeFormatAvatarUpdateResponseModel? small,
      @JsonKey(name: "medium")
      final SizeFormatAvatarUpdateResponseModel? medium,
      @JsonKey(name: "thumbnail")
      final SizeFormatAvatarUpdateResponseModel?
          thumbnail}) = _$FormatsAvatarUpdateResponseModelImpl;

  factory _FormatsAvatarUpdateResponseModel.fromJson(
          Map<String, dynamic> json) =
      _$FormatsAvatarUpdateResponseModelImpl.fromJson;

  @override
  @JsonKey(name: "small")
  SizeFormatAvatarUpdateResponseModel? get small;
  @override
  @JsonKey(name: "medium")
  SizeFormatAvatarUpdateResponseModel? get medium;
  @override
  @JsonKey(name: "thumbnail")
  SizeFormatAvatarUpdateResponseModel? get thumbnail;
  @override
  @JsonKey(ignore: true)
  _$$FormatsAvatarUpdateResponseModelImplCopyWith<
          _$FormatsAvatarUpdateResponseModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

SizeFormatAvatarUpdateResponseModel
    _$SizeFormatAvatarUpdateResponseModelFromJson(Map<String, dynamic> json) {
  return _SizeFormatAvatarUpdateResponseModel.fromJson(json);
}

/// @nodoc
mixin _$SizeFormatAvatarUpdateResponseModel {
  @JsonKey(name: "ext")
  String? get ext => throw _privateConstructorUsedError;
  @JsonKey(name: "url")
  String? get url => throw _privateConstructorUsedError;
  @JsonKey(name: "hash")
  String? get hash => throw _privateConstructorUsedError;
  @JsonKey(name: "mime")
  String? get mime => throw _privateConstructorUsedError;
  @JsonKey(name: "name")
  String? get name => throw _privateConstructorUsedError;
  @JsonKey(name: "path")
  dynamic get path => throw _privateConstructorUsedError;
  @JsonKey(name: "size")
  double? get size => throw _privateConstructorUsedError;
  @JsonKey(name: "width")
  int? get width => throw _privateConstructorUsedError;
  @JsonKey(name: "height")
  int? get height => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SizeFormatAvatarUpdateResponseModelCopyWith<
          SizeFormatAvatarUpdateResponseModel>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SizeFormatAvatarUpdateResponseModelCopyWith<$Res> {
  factory $SizeFormatAvatarUpdateResponseModelCopyWith(
          SizeFormatAvatarUpdateResponseModel value,
          $Res Function(SizeFormatAvatarUpdateResponseModel) then) =
      _$SizeFormatAvatarUpdateResponseModelCopyWithImpl<$Res,
          SizeFormatAvatarUpdateResponseModel>;
  @useResult
  $Res call(
      {@JsonKey(name: "ext") String? ext,
      @JsonKey(name: "url") String? url,
      @JsonKey(name: "hash") String? hash,
      @JsonKey(name: "mime") String? mime,
      @JsonKey(name: "name") String? name,
      @JsonKey(name: "path") dynamic path,
      @JsonKey(name: "size") double? size,
      @JsonKey(name: "width") int? width,
      @JsonKey(name: "height") int? height});
}

/// @nodoc
class _$SizeFormatAvatarUpdateResponseModelCopyWithImpl<$Res,
        $Val extends SizeFormatAvatarUpdateResponseModel>
    implements $SizeFormatAvatarUpdateResponseModelCopyWith<$Res> {
  _$SizeFormatAvatarUpdateResponseModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ext = freezed,
    Object? url = freezed,
    Object? hash = freezed,
    Object? mime = freezed,
    Object? name = freezed,
    Object? path = freezed,
    Object? size = freezed,
    Object? width = freezed,
    Object? height = freezed,
  }) {
    return _then(_value.copyWith(
      ext: freezed == ext
          ? _value.ext
          : ext // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      hash: freezed == hash
          ? _value.hash
          : hash // ignore: cast_nullable_to_non_nullable
              as String?,
      mime: freezed == mime
          ? _value.mime
          : mime // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as dynamic,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double?,
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SizeFormatAvatarUpdateResponseModelImplCopyWith<$Res>
    implements $SizeFormatAvatarUpdateResponseModelCopyWith<$Res> {
  factory _$$SizeFormatAvatarUpdateResponseModelImplCopyWith(
          _$SizeFormatAvatarUpdateResponseModelImpl value,
          $Res Function(_$SizeFormatAvatarUpdateResponseModelImpl) then) =
      __$$SizeFormatAvatarUpdateResponseModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "ext") String? ext,
      @JsonKey(name: "url") String? url,
      @JsonKey(name: "hash") String? hash,
      @JsonKey(name: "mime") String? mime,
      @JsonKey(name: "name") String? name,
      @JsonKey(name: "path") dynamic path,
      @JsonKey(name: "size") double? size,
      @JsonKey(name: "width") int? width,
      @JsonKey(name: "height") int? height});
}

/// @nodoc
class __$$SizeFormatAvatarUpdateResponseModelImplCopyWithImpl<$Res>
    extends _$SizeFormatAvatarUpdateResponseModelCopyWithImpl<$Res,
        _$SizeFormatAvatarUpdateResponseModelImpl>
    implements _$$SizeFormatAvatarUpdateResponseModelImplCopyWith<$Res> {
  __$$SizeFormatAvatarUpdateResponseModelImplCopyWithImpl(
      _$SizeFormatAvatarUpdateResponseModelImpl _value,
      $Res Function(_$SizeFormatAvatarUpdateResponseModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ext = freezed,
    Object? url = freezed,
    Object? hash = freezed,
    Object? mime = freezed,
    Object? name = freezed,
    Object? path = freezed,
    Object? size = freezed,
    Object? width = freezed,
    Object? height = freezed,
  }) {
    return _then(_$SizeFormatAvatarUpdateResponseModelImpl(
      ext: freezed == ext
          ? _value.ext
          : ext // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      hash: freezed == hash
          ? _value.hash
          : hash // ignore: cast_nullable_to_non_nullable
              as String?,
      mime: freezed == mime
          ? _value.mime
          : mime // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as dynamic,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double?,
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SizeFormatAvatarUpdateResponseModelImpl
    implements _SizeFormatAvatarUpdateResponseModel {
  const _$SizeFormatAvatarUpdateResponseModelImpl(
      {@JsonKey(name: "ext") this.ext,
      @JsonKey(name: "url") this.url,
      @JsonKey(name: "hash") this.hash,
      @JsonKey(name: "mime") this.mime,
      @JsonKey(name: "name") this.name,
      @JsonKey(name: "path") this.path,
      @JsonKey(name: "size") this.size,
      @JsonKey(name: "width") this.width,
      @JsonKey(name: "height") this.height});

  factory _$SizeFormatAvatarUpdateResponseModelImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$SizeFormatAvatarUpdateResponseModelImplFromJson(json);

  @override
  @JsonKey(name: "ext")
  final String? ext;
  @override
  @JsonKey(name: "url")
  final String? url;
  @override
  @JsonKey(name: "hash")
  final String? hash;
  @override
  @JsonKey(name: "mime")
  final String? mime;
  @override
  @JsonKey(name: "name")
  final String? name;
  @override
  @JsonKey(name: "path")
  final dynamic path;
  @override
  @JsonKey(name: "size")
  final double? size;
  @override
  @JsonKey(name: "width")
  final int? width;
  @override
  @JsonKey(name: "height")
  final int? height;

  @override
  String toString() {
    return 'SizeFormatAvatarUpdateResponseModel(ext: $ext, url: $url, hash: $hash, mime: $mime, name: $name, path: $path, size: $size, width: $width, height: $height)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SizeFormatAvatarUpdateResponseModelImpl &&
            (identical(other.ext, ext) || other.ext == ext) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.hash, hash) || other.hash == hash) &&
            (identical(other.mime, mime) || other.mime == mime) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other.path, path) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, ext, url, hash, mime, name,
      const DeepCollectionEquality().hash(path), size, width, height);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SizeFormatAvatarUpdateResponseModelImplCopyWith<
          _$SizeFormatAvatarUpdateResponseModelImpl>
      get copyWith => __$$SizeFormatAvatarUpdateResponseModelImplCopyWithImpl<
          _$SizeFormatAvatarUpdateResponseModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SizeFormatAvatarUpdateResponseModelImplToJson(
      this,
    );
  }
}

abstract class _SizeFormatAvatarUpdateResponseModel
    implements SizeFormatAvatarUpdateResponseModel {
  const factory _SizeFormatAvatarUpdateResponseModel(
          {@JsonKey(name: "ext") final String? ext,
          @JsonKey(name: "url") final String? url,
          @JsonKey(name: "hash") final String? hash,
          @JsonKey(name: "mime") final String? mime,
          @JsonKey(name: "name") final String? name,
          @JsonKey(name: "path") final dynamic path,
          @JsonKey(name: "size") final double? size,
          @JsonKey(name: "width") final int? width,
          @JsonKey(name: "height") final int? height}) =
      _$SizeFormatAvatarUpdateResponseModelImpl;

  factory _SizeFormatAvatarUpdateResponseModel.fromJson(
          Map<String, dynamic> json) =
      _$SizeFormatAvatarUpdateResponseModelImpl.fromJson;

  @override
  @JsonKey(name: "ext")
  String? get ext;
  @override
  @JsonKey(name: "url")
  String? get url;
  @override
  @JsonKey(name: "hash")
  String? get hash;
  @override
  @JsonKey(name: "mime")
  String? get mime;
  @override
  @JsonKey(name: "name")
  String? get name;
  @override
  @JsonKey(name: "path")
  dynamic get path;
  @override
  @JsonKey(name: "size")
  double? get size;
  @override
  @JsonKey(name: "width")
  int? get width;
  @override
  @JsonKey(name: "height")
  int? get height;
  @override
  @JsonKey(ignore: true)
  _$$SizeFormatAvatarUpdateResponseModelImplCopyWith<
          _$SizeFormatAvatarUpdateResponseModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}
